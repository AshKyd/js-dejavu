{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"dejavu","google":"UA-35166457-1","tagline":"A set of object-oriented tools for JavaScript","body":"# dejavu #\r\n\r\n---\r\n\r\n[![Build Status](https://secure.travis-ci.org/IndigoUnited/dejavu.png)](http://travis-ci.org/IndigoUnited/dejavu)\r\n\r\nHave you ever had the feeling that you're seeing something you've already seen\r\nbefore? That's the feeling you get when using `dejavu`.\r\n\r\nIf you are a developer coming from a language like PHP, Java, ActionScript 3.0,\r\nand others, it's likely that you are already familiar with Object Oriented\r\nProgramming. However, JavaScript uses prototypal inheritance which, although\r\npowerful and flexible, can be difficult to understand, and specially to maintain\r\nin large projects.\r\n\r\n`dejavu` is a library that delivers classical inheritance on top of JavaScript\r\nprototypal inheritance, making it a breeze to move into JavaScript.\r\n\r\n\r\n\r\n## Why another? ##\r\n\r\nThere are some libraries out there able to shim classical inheritance,\r\nhowever none offers all the functionality that many programmers require.\r\nAlso, even though being one of the most feature rich OOP libraries out there, it has one of the best performances, rivaling with vanilla JS in production.\r\n\r\n\r\n\r\n## Features ##\r\n\r\n* Concrete classes\r\n* Abstract classes\r\n* Interfaces\r\n* Mixins (so you can get some sort of multiple inheritance)\r\n* Private and protected members\r\n* Static members\r\n* Constants\r\n* Ability to declare true singletons via protected/private constructors\r\n* Context binding for functions\r\n* Method signature checks\r\n* Possible to extend or borrow from vanilla classes\r\n* Custom instanceOf with support for Interfaces\r\n* Classes and instances are locked by default\r\n    * Functions cannot be added, replaced or deleted\r\n    * Properties can only be modified\r\n* Two builds, `regular` and `AMD` based\r\n    * `AMD` optimized for speeding up developer workflow, allowing testing\r\n      without the need to re-compile everything into a single file\r\n    * `regular` if you are not using `AMD` in your projects\r\n* Two modes for each build, `strict` and `loose`\r\n    * `strict` best in development, enforcing a lot of checks, making sure you\r\n      don't make many typical mistakes\r\n    * `loose` best for production, without checks, improving performance\r\n\r\nUsers are encouraged to declare\r\n['use strict'](https://developer.mozilla.org/en/JavaScript/Strict_mode) while\r\nusing the `dejavu` in strict mode, otherwise some code might fail silently.\r\nThis can happen because `dejavu` uses `Object.freeze` and `Object.seal` to lock\r\nclasses and instances, guaranteeing that no one changes the behaviour of your\r\nclasses by replacing methods, etc, and possibly breaking your code, making it\r\nreally hard to pin point what's wrong. Altough this is the default behavior, it can be changed.\r\nYou will read more on it later in this document.\r\n\r\n**Do not confuse 'use strict' with the dejavu strict mode.**\r\n\r\n\r\n\r\n## Works on ##\r\n\r\n* IE (6+)\r\n* Chrome (4+)\r\n* Safari (3+)\r\n* Firefox (3.6+)\r\n* Opera (9+)\r\n* Node.js and Rhino\r\n\r\n\r\n\r\n## Getting started ##\r\n\r\nThe quickest way to start using `dejavu` in your project, is by simply including\r\n`dist/regular/strict/dejavu.js` (note that this is in __strict__ mode).\r\n\r\nIf you're developing a __client-side__ app, simply put the file in some folder,\r\nand include it in the HTML:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n        <script type=\"text/javascript\" src=\"dejavu.js\"></script>\r\n    </head>\r\n    <body>\r\n        <script type=\"text/javascript\">\r\n            'use strict';\r\n\r\n            // Declare the \"Person\" class\r\n            var Person = dejavu.Class.declare({\r\n                _name: null,\r\n\r\n                initialize: function(name) {\r\n                    this.setName(name);\r\n                },\r\n\r\n                setName: function(name) {\r\n                    this._name = name;\r\n\r\n                    return this;\r\n                },\r\n\r\n                getName: function() {\r\n                    return this._name;\r\n                }\r\n            });\r\n\r\n            // Create a new instance of person\r\n            var indigo = new Person('Marco');\r\n            console.log('A new indigo was born,', indigo.getName());\r\n        </script>\r\n    </body>\r\n</html>\r\n```\r\n\r\nThis will make a `dejavu` global available for you.\r\nIf you're developing in __Node.js__, install it with `npm install dejavu` and use it like so:\r\n\r\n```js\r\nvar dejavu = require('dejavu');\r\n\r\n// Declare the \"Person\" class\r\nvar Person = dejavu.Class.declare({\r\n    _name: null,\r\n\r\n    initialize: function(name) {\r\n        this.setName(name);\r\n    },\r\n\r\n    setName: function(name) {\r\n        this._name = name;\r\n\r\n        return this;\r\n    },\r\n\r\n    getName: function() {\r\n        return this._name;\r\n    }\r\n});\r\n\r\n// Create a new instance of person\r\nvar indigo = new Person(\"Marco\");\r\nconsole.log(\"A new indigo was born,\", indigo.getName());\r\n```\r\n\r\nIn node, the default mode running will be the strict mode unless the STRICT environmen\r\n variable is set to false.\r\nEnvironment variables can be changed system wide or per process like so:\r\n\r\n```js\r\nprocess.env.STRICT = false;\r\n```\r\n\r\n\r\n\r\n## Performance ##\r\n\r\nSince all those nice features and common rules of classic OOP degrade\r\nperformance, `dejavu` has two separates modes, for different stages in the\r\ndevelopment.\r\n\r\nThe `strict` mode is suitable for __development__, and will do all sorts of\r\nchecks, throwing an error when you try to do something considered illegal.\r\n\r\n**Note that if your project works in strict mode, it will work in loose mode.**\r\n\r\nAs for the `loose` mode, there is no overhead associated with checks, thus\r\nmaking it suitable for __production__, since it will be more efficient and\r\nhave a __lower memory footprint and filesize__.\r\n\r\nFinally, in order to achieve that extra edge, that puts `dejavu` next to vanilla\r\nJS in terms of performance, you should run the optimizer that is bundled with\r\nthe library. Note that this step is completely optional, and `dejavu` will still\r\nperform faster than the other libraries in most browsers, even if you don't run\r\nthe optimizer. The optimizer will analyse your code, and make some improvements\r\nboosting it a bit further.\r\n\r\nYou can check the benchmarks in [jsperf](http://jsperf.com/oop-benchmark/58)\r\ncomparing `dejavu` with other OOP libraries. Note that the loose mode\r\nis used in this test, simulating a production environment, and both the normal\r\nand optimized versions are tested.\r\n\r\n\r\n\r\n## Taking it to another level\r\n\r\n\r\nFront-end devs are encouraged to program using the AMD paradigm because of its obvious benefits.\r\nSince dejavu is built upon it, it will integrate seamlessly with your AMD loader.\r\nThe easy way to set it up is to define a path for dejavu in your loader config like so:\r\n\r\n```js\r\n{\r\n   // Your loader config\r\n   paths: {\r\n       'dejavu': '/path/to/dejavu/dist/strict/main'     // You can switch to the loose mode anytime\r\n   }\r\n}\r\n```\r\n\r\nThen require it and use it:\r\n\r\n```js\r\ndefine(['dejavu'], function (dejavu) {\r\n\r\n    // The dejavu variable is an object that contains:\r\n    // Class\r\n    // FinalClass\r\n    // AbstractClass\r\n    // Interface\r\n    // instanceOf\r\n    // options\r\n\r\n    // Example usage\r\n    var MyClass = dejavu.Class.declare({\r\n        initialize: function () {\r\n            // ...\r\n        }\r\n    });\r\n\r\n    return MyClass;\r\n});\r\n```\r\n\r\nIf you just want to require specific parts of `dejavu`, you can do so.\r\nIn order to achieve this, you must configure your loader like so:\r\n\r\n```js\r\n{\r\n    // Your loader config\r\n    packages: [\r\n        {\r\n            name: 'dejavu',\r\n            location: '/path/to/dejavu/dist/strict'     // You can switch to the loose mode anytime\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nWith this setup, you can still require the dejavu object like shown above or require specific parts of it:\r\n\r\n```js\r\ndefine(['dejavu/Class'], function (Class) {\r\n\r\n    // Example usage\r\n    var MyClass = dejavu.Class.declare({\r\n        initialize: function () {\r\n            // ...\r\n        }\r\n    });\r\n\r\n    return MyClass;\r\n});\r\n```\r\n\r\nAs you can see, in this case, only the `Class` module of `dejavu` is included,\r\nwhich means all the other modules are not loaded.\r\n\r\n\r\n\r\n## Syntax\r\n\r\n### Interface definition ###\r\n\r\nObject interfaces allow you to create code which specifies which methods a class must implement, without having to define how these methods are handled.\r\nBelow there's an example of an _EventsInterface_ that has the role of adding event listeners and fire events:\r\n\r\n```js\r\ndefine(['dejavu/Interface'], function (Interface) {\r\n\r\n    'use strict';\r\n\r\n    var EventsInterface = Interface.declare({\r\n        $name: 'EventsInterface',                       // Will make easier to debug mistakes (optional)\r\n\r\n        addListener: function (name, fn, context) {},\r\n\r\n        removeListener: function (name, fn) {},\r\n\r\n        fireEvent: function (name, args) {}\r\n    });\r\n\r\n    return EventsInterface;\r\n});\r\n```\r\n\r\nInterfaces can extend multiple interfaces. They can also define static functions signature.\r\nBe aware that all functions must obey its base signature (see explanation later in this document).\r\n\r\n```js\r\ndefine(['path/to/EventsInterface', 'dejavu/Interface'], function (EventsInterface, Interface) {\r\n\r\n    'use strict';\r\n\r\n    var SomeEventsInterface = Interface.declare({\r\n        $name: 'SomeEventsInterface',\r\n        $extends: EventsInterface,   // This interface extends EventsInterface\r\n                                     // Interfaces can extend multiple ones, just reference them in an array\r\n\r\n        $statics: {                  // This is how we define statics\r\n            getTotalListeners: function () {}\r\n        }\r\n\r\n    });\r\n\r\n    return SomeEventsInterface;\r\n});\r\n```\r\nAlternatively, one can extend an interface with the extend() function. The equivalent code of the shown above is:\r\n\r\n```js\r\ndefine(['path/to/EventsInterface', 'dejavu/Interface'], function (EventsInterface, Interface) {\r\n\r\n    'use strict';\r\n\r\n    var SomeEventsInterface = EventsInterface.extend({\r\n        $name: 'SomeEventsInterface',\r\n\r\n        $statics: {                  // This is how we define statics\r\n            getTotalListeners: function () {}\r\n        }\r\n\r\n    });\r\n\r\n    return SomeEventsInterface;\r\n});\r\n```\r\n\r\n\r\n\r\n### Interface usage example ###\r\n\r\nA class that implements an interface must define all the interface methods and be compatible with their signature.\r\nYou define that a class implements an interface by specifying it in the $implements keyword.\r\nThe $implements keyword can be an interface or an array of interfaces.\r\nFollowing the previous example we can define a concrete class - _EventsEmitter_ - that implements the _EventsInterface_ interface.\r\n\r\n```js\r\ndefine([\r\n    'path/to/EventsInterface',\r\n    'dejavu/Class'\r\n], function (EventsInterface, Class) {\r\n\r\n    'use strict';\r\n\r\n    var EventsEmitter = Class.declare({\r\n        $name: 'EventsEmitter',\r\n        $implements: EventsInterface,   // The class implements the EventsInterface interface\r\n                                        // You can specify multiple interfaces in an array\r\n\r\n        addListener: function (name, fn, context) {\r\n            // Implementation goes here\r\n        },\r\n\r\n        removeListener: function (name, fn) {\r\n            // Implementation goes here\r\n        },\r\n\r\n        fireEvent: function (name, args) {\r\n            // Implementation goes here\r\n        }\r\n    });\r\n\r\n    return EventsEmitter;\r\n});\r\n```\r\n\r\n\r\n\r\n### Abstract classes ###\r\n\r\nClasses defined as abstract may not be instantiated, and any class that contains at least one abstract method must also be abstract.\r\nMethods defined as abstract simply declare the method's signature.\r\nWhen an abstract class implements an interface and doesn't implement some of its methods, those will be automatically declared as abstract.\r\nBelow there is an example of an abstract class - _AbstractEmitter_ - that implements all of the _EventsInterface_ interface methods, except the _fireEvent()_ method.\r\n\r\n```js\r\ndefine([\r\n    'path/to/EventsInterface',\r\n    'dejavu/AbstractClass'\r\n],\r\nfunction (EventsInterface, AbstractClass) {\r\n\r\n    'use strict';\r\n\r\n    var AbstractEventsEmitter = AbstractClass.declare({\r\n        $name: 'AbstractEventsEmitter',\r\n        $implements: EventsInterface,   // The class must implement the EventsInterface\r\n\r\n        initialize: function (argument1) {\r\n            // This is the constructor\r\n            // Calling new on an abstract class will throw an error\r\n            // Though a class that extends this abstract class will run this constructor if called\r\n        },\r\n\r\n        addListener: function (name, fn, context) {\r\n            // Implementation goes here\r\n        },\r\n\r\n        removeListener: function (name, fn) {\r\n            // Implementation goes here\r\n        },\r\n\r\n        // fireEvent() is not implemented, therefore is automatically declared as abstract\r\n\r\n        $abstracts: {                   // This how we defined abstract methods\r\n\r\n            removeAll: function () {},\r\n\r\n            $statics: {                 // We can also define abstract static methods\r\n                getTotalListeners: function () {}\r\n            }\r\n        }\r\n    });\r\n\r\n    return AbstractEventsEmitter;\r\n});\r\n```\r\n\r\nAbstract classes can extend other abstract classes or concrete classes while implementing other interfaces.\r\n\r\n```js\r\ndefine([\r\n    'path/to/some/class',\r\n    'path/to/some/interface',\r\n    'path/to/other/interface',\r\n    'dejavu/AbstractClass'\r\n],\r\nfunction (SomeClass, SomeInterface, OtherInterface, AbstractClass) {\r\n\r\n    'use strict';\r\n\r\n    var ComplexAbstractClass = AbstractClass.declare({\r\n        $name: 'ComplexAbstractClass',\r\n        $extends: SomeClass,\r\n        $implements: [SomeInterface, OtherInterface],\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function (argument1) {\r\n            // Call super\r\n            this.$super(argument1);\r\n\r\n            // Do other things here\r\n        },\r\n\r\n        $statics: {\r\n            // Some class static members\r\n        },\r\n\r\n        $abstracts: {\r\n\r\n            // Some abstract functions\r\n\r\n            $statics: {\r\n                // Some abstract static functions\r\n            }\r\n        }\r\n    });\r\n\r\n    return ComplexAbstractClass;\r\n});\r\n```\r\n\r\nAlternatively, one can extend a concrete or abstract class with the extend() function. The equivalent code of the shown above is:\r\n\r\n```js\r\ndefine([\r\n    'path/to/some/class',\r\n    'path/to/some/interface',\r\n    'path/to/other/interface',\r\n    'dejavu/AbstractClass'\r\n],\r\nfunction (SomeClass, SomeInterface, OtherInterface, AbstractClass) {\r\n\r\n    'use strict';\r\n\r\n    var ComplexAbstractClass = SomeClass.extend({\r\n        $name: 'ComplexAbstractClass',\r\n        $implements: [SomeInterface, OtherInterface],\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function (argument1) {\r\n            // Call super\r\n            this.$super(argument1);\r\n\r\n            // Do other things here\r\n        },\r\n\r\n        $statics: {\r\n            // Some class static members\r\n        },\r\n\r\n        $abstracts: {\r\n\r\n            // Some abstract functions\r\n\r\n            $statics: {\r\n                // Some abstract static functions\r\n            }\r\n        }\r\n    });\r\n\r\n    return ComplexAbstractClass;\r\n});\r\n```\r\n\r\n\r\n\r\n### Concrete classes ###\r\n\r\nConcrete classes can extend other concrete classes or abstract classes as well as implement several interfaces.\r\nThey differ from abstract classes in the way that they can't have abstract methods.\r\nBelow is described the full syntax that can be used in concrete and abstract classes.\r\n\r\n```js\r\ndefine([\r\n    'path/to/some/class',\r\n    'path/to/other/class',\r\n    'path/to/some/interface',\r\n    'path/to/other/interface',\r\n    'dejavu/Class'\r\n],\r\nfunction (SomeClass, OtherClass, SomeInterface, OtherInterface, Class) {\r\n\r\n    'use strict';\r\n\r\n    var ConcreteClass = Class.declare({\r\n        $name: 'ConcreteClass',\r\n        $extends: SomeClass,\r\n        $implements: [SomeInterface, OtherInterface],\r\n        $borrows: OtherClass,                           // We can add mixins by specifying them in here\r\n                                                        // You can specify multiple mixins in an array\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function () {\r\n            // Call super\r\n            this.$super();\r\n\r\n            // Do other things here\r\n        },\r\n\r\n        $statics: {\r\n            // Some class static members\r\n        }\r\n    });\r\n});\r\n```\r\n\r\n\r\n\r\n### Mixins ###\r\n\r\nA mixin is a class or object that provides a certain functionality to be reused by other classes, since all their members will be copied (expect for the initialize method).\r\nMixins can be used like specified in the example above.\r\nIf clashes occur with multiple mixins, that last one takes precedence.\r\n\r\n\r\n\r\n### Binds ###\r\n\r\nThe $bind() function allows you to bind a anonymous functions to the instance to preserve the context as well as allowing private/protected methods invocations.\r\n\r\n```js\r\ndefine([\r\n    'dejavu/Class'\r\n],\r\nfunction (Class) {\r\n\r\n    'use strict';\r\n\r\n    var ConcreteClass = Class.declare({\r\n        $name: 'ConcreteClass',\r\n\r\n        /**\r\n         * Constructor.\r\n         */\r\n        initialize: function (element) {\r\n            element.addEventListener('click', function () {\r\n                console.log('caught click');\r\n                this._doSomething();\r\n            }.$bind(this));                                                    // Use the $bind\r\n\r\n            element.addEventListener('keydown', this.$bind(function () {\r\n                console.log('caught keydown');\r\n                this._doSomething();                                           // Use the this.$bind (same behavior as above)\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Some protected method\r\n         */\r\n        _doSomething: function () {\r\n            // ..\r\n        }\r\n    });\r\n});\r\n```\r\nAlternatively, the $bound() function allows you to bind a class function to the instance.\r\nThis is useful if certain functions are meant to be used as callbacks or handlers.\r\nYou don't need to bind the function manually, it will be bound for you automatically.\r\n\r\n```js\r\ndefine([\r\n    'dejavu/Class'\r\n],\r\nfunction (Class) {\r\n\r\n    'use strict';\r\n\r\n    var ConcreteClass = Class.declare({\r\n        $name: 'ConcreteClass',\r\n\r\n        /**\r\n         * Constructor.\r\n         */\r\n        initialize: function (element) {\r\n            element.addEventListener('click', this._handleClick);\r\n        },\r\n\r\n        /**\r\n         * Handles some click event.\r\n         */\r\n        _handleClick: function () {\r\n            // Handle click here\r\n        }.$bound()\r\n    });\r\n});\r\n```\r\n\r\n### Constants ###\r\n\r\nThe $constants keyword allows you to defined constants.\r\nIf Object.defineProperty is available, any attempt to modify the constant value will throw an error (only in the strict mode).\r\nConstants can be defined in classes, abstract classes and interfaces.\r\n\r\n```js\r\ndefine(['dejavu/Class', function (Class) {\r\n\r\n    'use strict';\r\n\r\n    var SomeClass = Class.declare({\r\n        $name: 'SomeClass',\r\n\r\n        $constants: {\r\n            FOO: 'bar'\r\n            BAR: 'foo'\r\n        },\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function () {\r\n            this.$self.FOO;    // 'bar'\r\n            SomeClass.FOO;     // 'bar' (is the same as above)\r\n        }\r\n    });\r\n\r\n    SomeClass.FOO; // 'bar'\r\n    SomeClass.BAR; // 'foo'\r\n\r\n    return SomeClass;\r\n});\r\n```\r\n\r\n\r\n### Final members/classes ###\r\n\r\nMembers that are declared as final cannot be overriden by a child class.\r\nIf the class itself is being defined final then it cannot be extended.\r\n\r\n```js\r\ndefine(['dejavu/FinalClass', function (FinalClass) {\r\n\r\n    'use strict';\r\n\r\n    var SomeClass = FinalClass.declare({    // This class cannot be extended\r\n        $name: 'SomeClass',\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function () {\r\n            // ...\r\n        }\r\n    });\r\n\r\n    return SomeClass;\r\n});\r\n\r\ndefine(['dejavu/Class', function (Class) {\r\n\r\n    'use strict';\r\n\r\n    var SomeClass = Class.declare({\r\n        $name: 'SomeClass',\r\n\r\n        /**\r\n         * Class constructor.\r\n         */\r\n        initialize: function () {\r\n            // ...\r\n        },\r\n\r\n        $finals: {                  // Classes that extend this one are not allowed to override the members below\r\n\r\n            someMethod: function () {\r\n                // ...\r\n            },\r\n            someProperty: 'foo',\r\n\r\n            $statics: {             // We can also define static methods as final\r\n                staticMethod: function () {\r\n                    // ...\r\n                },\r\n                staticProperty: 'bar'\r\n            }\r\n    });\r\n\r\n    return SomeClass;\r\n});\r\n\r\n```\r\n\r\n### Protected and private members ###\r\n\r\nProtected and private members should be prefixed with _ and __ respectively.\r\nIf Object.defineProperty is available, it will be used to manage their access (only in the strict mode).\r\n\r\n\r\n\r\n### Signature check ###\r\n\r\nAll functions are virtual functions, therefore they can be overriden except if they are classified as final.\r\nAdditionally, if a method is abstract, a subclass can only implement/override it if they obey their signature (must be equal or augmented with additional optional arguments).\r\nArguments prefixed with a $ are evaluated as optional. The signature check is done for all abstract functions (interface functions are also considered abstract).\r\n\r\n```js\r\nvar SomeAbstractClass = AbstractClass.declare({\r\n    $abstracts: {\r\n        foo: function (param1) {}\r\n    }\r\n});\r\n\r\nvar SomeClass = Class.declare({\r\n    $extends: SomeAbstractClass,\r\n\r\n    foo: function (param1) {             // Signature is equal, it's valid\r\n        // Do something here\r\n    }\r\n});\r\n\r\nvar ComplexClass = Class.declare({\r\n    $extends: SomeClass,\r\n\r\n    foo: function (param1, $param2) {    // Although it's signature is not equal, was augmented with an additional optional argument, so it's valid\r\n        // Do something here\r\n    }\r\n});\r\n\r\nvar OtherComplexClass = Class.declare({\r\n    $extends: SomeClass,\r\n\r\n    foo: function (param1, param2) {     // Will throw an error because foo(param1) is not compatible with foo(param1, param2)\r\n        // Do something here\r\n    }\r\n});\r\n```\r\n\r\n\r\n### Calling static methods within an instance ###\r\n\r\nTo call static methods inside an instance you can use $self and $static.\r\n$self gives access to the class itself and $static gives access to the called class in a context of static inheritance.\r\n$self is the same as using the class variable itself.\r\n\r\n```js\r\nvar Example1 = Class.declare({\r\n    foo: function (param1) {\r\n        return this.$self.bar;    // same as Example1.bar;\r\n    },\r\n    $statics: {\r\n        bar: 'hello'\r\n    }\r\n});\r\n\r\nvar Example2 = Class.declare({\r\n    foo: function (param1) {\r\n        return this.$static.bar;\r\n    },\r\n    $statics: {\r\n        bar: 'hello'\r\n    }\r\n});\r\n\r\nvar Example3 = Class.declare({\r\n    $extends: Example1\r\n    $statics: {\r\n        bar: 'bye'\r\n    }\r\n});\r\n\r\nvar Example4 = Class.declare({\r\n    $extends: Example2\r\n    $statics: {\r\n        bar: 'bye'\r\n    }\r\n});\r\n\r\nExample3.foo(); // hello\r\nExample4.foo(); // bye\r\n```\r\n\r\n\r\n\r\n### instanceOf ###\r\n\r\nThe instanceOf function works exactly the same way as the native instanceof except that it also works for interfaces.\r\n\r\n\r\n\r\n###  Classes and instances are locked ###\r\n\r\nBy default, constructors and instances are locked. This means that no one can monkey patch your code.\r\nThis behaviour can be changed in two ways:\r\n\r\n#### With the $locked flag:\r\n\r\n```js\r\nvar MyUnlockedClass = Class.declare({\r\n    $name: 'MyUnlockedClass',\r\n    $locked: false\r\n\r\n    initialize: function () {\r\n        this.foo = 'bar';           // Altough the foo property is not declared,\r\n                                    // it will not throw an error\r\n    },\r\n\r\n    run: function () {\r\n        console.log('run!');\r\n    }\r\n});\r\n\r\nMyUnlockedClass.prototype.run = function () {   // Methods can be replaced in the prototype\r\n    console.log('im running!');\r\n};\r\n\r\nvar myUnlockedInstance = new MyUnlockedClass();\r\nmyUnlockedInstance.undeclaredProperty = 'foo'   // Properties can be added to the instance\r\nmyUnlockedInstance.run = function () {          // Methods can be replaced in the instance\r\n    console.log('im running naked!');\r\n};\r\n```\r\n\r\n#### By setting the global option:\r\n\r\nThis will change the default behaviour, but classes can still override it with the $locked flag.\r\n\r\n```\r\ndejavu.options.locked = false;\r\n```\r\n\r\nNote that once a class is unlocked, its subclasses cannot be locked.\r\nAlso, although undeclared members are allowed, they will not have their access controlled (they are interpreted as public).\r\n### Notes ###\r\n\r\nPlease avoid using object constructors for strings, objects, booleans and numbers:\r\n\r\n```js\r\nvar MyClass = Class.declare({\r\n    foo: new String('bar'),  // Don't use this\r\n    foz: 'bar'               // Ok\r\n});\r\n```\r\n\r\n\r\n\r\n## Optimizer ##\r\n\r\ndejavu bundles an optimizer that makes your code faster and lighter.\r\nIt specifically:\r\n\r\n* Improves $super and $self usage\r\n* Removes all $name and $locked properties because they are not used in the loose version\r\n* Removes the need for wrappers, improving performance by a great margin\r\n* Removes abstract functions from abstract classes\r\n* Removes functions from interfaces\r\n\r\nThe optimizer is located in the `bin` folder.\r\nExample usage:\r\n\r\n`node optimizer < file_in.js > file_out.js`\r\n\r\ndejavu also comes with a grunt task.\r\nBellow is a sample usage copied from a grunt file:\r\n\r\n```js\r\n\r\ngrunt.loadNpmTasks('dejavu');\r\n\r\ngrunt.initConfig({\r\n    dejavu: {\r\n        optimize: {\r\n            options: {\r\n                exclude: [/bootstrap(\\.min)?\\.js$/]\r\n            },\r\n            files: {\r\n                'dist/': 'src/**/*.js'\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Dependencies ##\r\n\r\ndejavu depends on [amd-utils](https://github.com/millermedeiros/amd-utils).\r\nIf you use the regular build, you don't need to worry because all functions used from amd-utils are bundled for you.\r\nIf you use it on node, npm will take care of getting the dependencies for you.\r\nIf you use the AMD build, you must specify the path to amd-utils.\r\nFor example, if you use [RequireJS](http://requirejs.org/):\r\n\r\n```js\r\n    paths : {\r\n        'amd-utils': '../vendor/amd-utils/src'\r\n    },\r\n\r\n    packages: [\r\n        {\r\n            name: 'dejavu'\r\n            location: '../../dist/amd/strict',\r\n        }\r\n    ]\r\n```\r\n\r\n\r\n\r\n## Building dejavu ##\r\n\r\nSimply run `npm install` to install all the tools needed.\r\nThen just run `npm run-script build` or `node build`.\r\n\r\n\r\n## Testing dejavu ##\r\n\r\nPlease take a look at the [test](https://github.com/IndigoUnited/dejavu/tree/master/test) section.\r\n\r\n\r\n\r\n## License ##\r\n\r\nReleased under the [MIT License](http://www.opensource.org/licenses/mit-license.php)."}
#!/usr/bin/env node

/*jshint node:true, regexp:false*/

'use strict';

var fs = require('fs'),
    program = require('commander'),
    esprima = require('esprima'),
    escodegen = require('escodegen'),
    Syntax = esprima.Syntax;

////////////////////////////////////////////////////

program
    .version('0.0.1')
    .option('-r, --remove-strict', 'Remove "use strict" code.')
    .parse(process.argv);

////////////////////////////////////////////////////

var parser = {

    /**
     *
     */
    forEachUsage: function (ast, callback) {
        var queue = [ast],
            curr,
            objectName,
            x,
            keys;

        while (queue.length) {
            curr = queue.pop();

            if (curr) {
                if (curr.type === Syntax.CallExpression &&
                    curr.callee.type === Syntax.MemberExpression &&
                    curr.callee.object.type === Syntax.Identifier &&
                    curr.callee.property.type === Syntax.Identifier &&
                    curr['arguments'].length && curr['arguments'][0].type === Syntax.ObjectExpression) {

                    objectName = curr.callee.object.name;

                    // Obvious usage
                    if (curr.callee.property.name === 'declare') {
                        if (objectName === 'Interface') {
                            callback({ type: 'interface', ast: curr });
                        } else if (objectName === 'AbstractClass') {
                            callback({ type: 'abstract', ast: curr });
                        } else if (objectName === 'Class' || objectName === 'FinalClass') {
                            callback({ type: 'concrete', ast: curr });
                        }
                    // Usage with extend
                    } else if (curr.callee.property.name === 'extend') {
                        if (parser._isInterface(curr['arguments'][0])) {
                            callback({ type: 'interface', ast: curr });
                        } else if (parser._isAbstractClass(curr['arguments'][0])) {
                            callback({ type: 'abstract', ast: curr });
                        } else if (parser._isClass(curr['arguments'][0])) {
                            callback({ type: 'concrete', ast: curr });
                        }
                    }
                }

                if (Object.prototype.toString.call(curr) === '[object Array]') {
                    for (x = curr.length - 1; x >= 0; x -= 1) {
                        queue.push(curr[x]);
                    }
                } else if (curr.type) {
                    keys = Object.keys(curr);

                    for (x = keys.length - 1; x >= 0; x -= 1) {
                        queue.push(curr[keys[x]]);
                    }
                }
            }
        }
    },


    /**
     *
     */
    optimizeInterface: function (ast) {
        // Step 1
        // Remove all the functions
        var asts = ast['arguments'][0].properties,
            x,
            curr;

        for (x = asts.length - 1; x >= 0; x -= 1) {
            curr = asts[x];

            if (curr.key.name === '$statics' || curr.type === Syntax.FunctionExpression) {
                asts.splice(x, 1);
            }
        }
    },

    /**
     *
     */
    optimizeAbstactClass: function (ast) {
        // Step 1
        // Remove abstracts
        var asts = ast['arguments'][0].properties,
            x;

        for (x = asts.length - 1; x >= 0; x -= 1) {
            if (asts[x].key.name === '$abstracts') {
                asts.splice(x, 1);
                break;
            }
        }
    },

    /**
     *
     */
    optimizeClass: function (ast) {
        var args = ast['arguments'],
            type = ast.callee.property.name,
            extend,
            funcExpression;

        // Step 1
        // Convert the object to a return function with the magical $ params
        funcExpression = {
            type: Syntax.FunctionExpression,
            id: null,
            params: [],
            body: {
                type: Syntax.BlockStatement,
                body: [
                    {
                        type: Syntax.ReturnStatement
                        // Return object will be here as the argument key
                    }
                ]
            }
        };

        if (type === 'extend' || (extend = parser._getExtends(args[0]))) {
            funcExpression.params.push(
                {
                    type: Syntax.Identifier,
                    name: '$super'
                },
                {
                    type: Syntax.Identifier,
                    name: '$self'
                },
                {
                    type: Syntax.Identifier,
                    name: '$parent'
                }
            );

            if (type !== 'extend') {
                parser._removeExtends(args[0]);
                ast['arguments'] = [
                    {
                        type: 'Identifier',
                        name: extend
                    },
                    funcExpression
                ];
            } else {
                ast['arguments'] = [funcExpression];
            }
        } else {
            funcExpression.params.push(
                {
                    type: Syntax.Identifier,
                    name: '$self'
                }
            );
            ast['arguments'] = [funcExpression];
        }

        funcExpression.body.body[0].argument = args[0];

        // Step 2
        // Replace all the this.$super / this.$static / this.$self accordingly
        // Be aware that depending on the context (normal or static, things must be adapted)
        parser._findAndParseFunctions(args[0].properties);
    },

    /**
     *
     */
    optimize: function (obj) {
        var type = obj.type,
            ast = obj.ast;

        // Detect and make the optimizations according to the type
        if (type === 'concrete') {
            parser.optimizeClass(ast);
        } else if (type === 'abstract') {
            parser.optimizeAbstactClass(ast);
            parser.optimizeClass(ast);
        } else if (type === 'interface') {
            parser.optimizeInterface(ast);
        }
    },

    _isClass: function (asts) {
        // Check if it has a $name, $statics, $finals, $constants
        var x,
            curr,
            known = ['$name', '$statics', '$finals', '$constants'];

        for (x = asts.length - 1; x >= 0; x -= 1) {
            curr = asts[x];

            if (known.indexOf(curr.key.name) !== -1) {
                return true;
            }
        }

        return false;
    },

    _isAbstractClass: function (asts) {
        // Check if it has an $abstracts
        var x,
            curr;

        for (x = asts.length - 1; x >= 0; x -= 1) {
            curr = asts[x];

            if (curr.key.name === '$abstracts') {
                return true;
            }
        }

        return false;
    },

    _isInterface: function (asts) {
        var x,
            curr;

        // Every single function must be empty
        // Also all the properties must be functions except a few ones ($extends, $name, $static)
        for (x = asts.length - 1; x >= 0; x -= 1) {
            curr = asts[x];

            if (curr.key.name === '$name' || curr.key.name === '$extends') {
                continue;
            }

            if (curr.key.name === '$statics') {
                if (!parser._isInterface(curr.value)) {
                    return false;
                }
            } else if (curr.type === Syntax.FunctionExpression) {
                if (curr.body.body.length) {
                    return false;
                }
            } else {
                return false;
            }
        }

        return true;
    },

    /**
     *
     */
    _findAndParseFunctions: function (asts, isStatic) {
        if (Object.prototype.toString.call(asts) !== '[object Array]') {
            return false;
        }

        var x,
            curr,
            currFuncName,
            efficient = true,
            ret;

        for (x = asts.length - 1; x >= 0; x -= 1) {
            curr = asts[x];

            if (curr.key.name === '$statics') {
                parser._findAndParseFunctions(curr.value.properties, true);
            } else if (curr.key.name === '$finals') {
                parser._findAndParseFunctions(curr.value.properties);
            } else if (curr.value.type === Syntax.FunctionExpression) {
                currFuncName = curr.key.name;
                ret = parser._replaceSpecial(currFuncName, curr, isStatic);
                if (!ret) {
                    efficient = false;
                }
            }
        }

        return efficient;
    },

    /**
     *
     */
    _replaceSpecial: function (funcName, ast, isStatic) {
        var code = escodegen.generate(ast.value),
            efficient = true;

        function superStaticReplacer() {
            efficient = false;
            return '$parent';
        }

        function selfReplacer() {
            efficient = false;
            return '$self';
        }

        // Super replacement
        code = code.replace(/(this|that)(?:\.|(?:[\'])?)\$super(?:'\])?\(/g, '$super.' + funcName + '.call($1, ')
                   .replace(/(this|that), \)/g, '$1)');

        // If on static replace, $super is actually $parent
        if (isStatic) {
            code = code.replace(/\$super/g, superStaticReplacer);
        }

        // Self replacement
        code = code.replace(/(this|that)(?:\.|(?:[\'])?)\$self(?:'\])?/g, selfReplacer);

        code = code.replace(/function\s*\(/, 'function x(');
        ast.value = esprima.parse(code).body[0];
        ast.value.id = null;
        ast.value.type = Syntax.FunctionExpression;

        return efficient;
    },

    /**
     *
     */
    _getExtends: function (ast) {
        var x,
            length = ast.properties.length;

        for (x = 0; x < length; x += 1) {
            if (ast.properties[x].key.name === '$extends') {
                return ast.properties[x].value.name;
            }
        }
    },

    /**
     *
     */
    _removeExtends: function (ast) {
        var x,
            length = ast.properties.length;

        for (x = 0; x < length; x += 1) {
            if (ast.properties[x].key.name === '$extends') {
                ast.properties.splice(x, 1);
                break;
            }
        }
    }

};

var len = fs.fstatSync(process.stdin.fd).size,
    contents = len > 0 ? fs.readSync(process.stdin.fd, len)[0] : '',
    ast,
    output;

// Read and get an ast
ast = esprima.parse(contents);

parser.forEachUsage(ast, function (obj) {
    parser.optimize(obj);
});

// Generate the source
output = escodegen.generate(ast);

// Output the file
process.stdout.write(output);

//process.stdout.write(JSON.stringify(ast, null, '    '));